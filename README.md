# Daily DSA Challenges

Welcome to my repository dedicated to daily Data Structures and Algorithms (DSA) challenges! This project is designed to help me practice and improve my coding skills by solving one problem each day.

## ðŸš€ Project Goals

- To strengthen my understanding of DSA concepts.
- To document my solutions and thought processes.
- To build a portfolio of coding challenges.

## ðŸ“š Languages and Technologies

- **Java**: Main programming language for challenges.

## ðŸ¥‡ Challenge Log

### Day 1: [Third Maximum Number](Day1_ThirdMax.java)
- **Description**: Given an integer array nums, return the third distinct maximum number in this array. If the third maximum does not exist, return the maximum number.
  
### Day 2: [Search Insert Position](Day2_SearchInsert.java)
- **Description**: Search for a target value in a sorted array or determine the position where it should be inserted.

### Day 3: [Remove Element](Day3_RemoveElement.java)
- **Description**: Remove all instances of a specific value from an array.

### Day 4: [Max Consecutive Ones](Day4_MaxConsecutiveOnes.java)
- **Description**: Find the maximum number of consecutive 1s in a binary array.

### Day 5: [Length of Last Word](Day5_LengthOfLastWord.java)
- **Description**: Given a string s consisting of words and spaces, return the length of the last word in the string.

A word is a maximal substring consisting of non-space characters only.

### Day 6: [FizzBuzz](Day6_FizzBuzz.java)
- **Description**: Print numbers from 1 to n, but for multiples of three print "Fizz," for multiples of five print "Buzz," and for multiples of both print "FizzBuzz."

### Day 7: [Spiral Matrix](Day7_SpiralMatrix.java)
- **Description**: Return all elements of a matrix in spiral order.

### Day 8: [Palindrome Number](Day8_PalindromeNumber.java)
- **Description**: Determine if a given number is a palindrome.

### Day 9: [Two Sum](Day9_twosum.java)
- **Description**: Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.

### Day 10: [Trapping Water](Day10_TrappingWater.java)
- **Description**: We need to calculate how much rainwater can be trapped between buildings after it rains. The buildings are represented by an array of heights, and the amount of water trapped depends on how tall the surrounding buildings are.

### Day 11: [Maximum Sub Array](Day11_MaxSubArray.java)
- **Description**: Given an integer array nums, find the subarray with the largest sum, and return its sum.

### Day 12: [Search in Rotated Sorted Array](Day12_SearchInArray.java)
- **Description**: Given an integer array nums, find the subarray with the largest sum, and return its sum.

### Day 13: [Container With Most Water](Day13_ContainerWithMostWater.java)
- **Description**: Find two lines that together with the x-axis form a container, such that the container contains the most water.

### Day 14: [Best Time to Buy and Sell Stock](Day14_BuySell.java)
- **Description**: You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.

### Day 15: [ Longest Palindromic Substring](Day15_LongestPalindrome.java)
- **Description**:Given a string s, return the longest palindromic substring in s.

### Day 16: [Find Minimum in Rotated Sorted Array](Day16_findMinimum.java)
- **Description**: Given the sorted rotated array nums of unique elements, return the minimum element of this array.

### Day 17: [longestCommonPrefix](Day17_longestCommonPrefix.java)
- **Description**: Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string "".

### Day 18: [Valid Anagram](Day18_ValidAnagram.java)
- **Description**: Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string "".

- **Solution Aproach**: 
1. Step-1:- 
- Create a HashMap.
2. Step-2 :-
- Iterate over the string and store the frequency of each character in the HashMap.
3. Step-3 :-
- Iterate over the string again and check if the frequency of each character in the HashMap is equal to
the frequency of the same character in the second string.
4. Step-4 :-
- Last Check if map.isEmpty() so return true, otherwise false.

### Day 19: [Valid Parentheses](Day19_ValidParentheses.java)
- **Description**: Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string "".

### Day 20: [Set Matrix Zeroes](Day20_SetMatrixZeroes.java)
- **Description**: Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's.

### Day 21: [Maximum Swap](Day21_MaximumSwap.java)
- **Description**: You are given an integer num. You can swap two digits at most once to get the maximum valued number.
Return the maximum valued number you can get.

### Day 22: [Is Subsequence](Day22_IsSubsequence.java)
- **Description**: Given two strings s and t, return true if s is a subsequence of t, or false otherwise..

### Day 23: [Word Search](Day23_WordSearch.java)
- **Description**: Given an m x n grid of characters board and a string word, return true if word exists in the grid.

### Day 24: [Merge Two Sorted Lists](Day24_MergeTwoSortedList.java)
- **Description**: You are given the heads of two sorted linked lists list1 and list2.
Merge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists.
Return the head of the merged linked list

### Day 25: [Reorder List](Day25_ReorderList.java)
- **Description**: You are given the head of a singly linked-list. The list can be represented as:
L0 â†’ L1 â†’ â€¦ â†’ Ln - 1 â†’ Ln
Reorder the list to be on the following form:
L0 â†’ Ln â†’ L1 â†’ Ln - 1 â†’ L2 â†’ Ln - 2 â†’ â€¦

### Day 26: [Missing Number](Day26_MissingNumber.java)
- **Description**: Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.

### Day 27: [Add Binary](Day27_AddBinary.java)
- **Description**: Given two binary strings a and b, return their sum as a binary string.

### Day 28: [Best Time to Buy and Sell Stock II ](Day28_BestTimetoBuyandSellStockII.java)
- **Description**: Today, I solved the Best Time to Buy and Sell Stock II problem, where the goal is to maximize profit by buying and selling stocks multiple times. Hereâ€™s my approach:

### Day 29: [Reverse Words in a String III](Day29_ReverseWordsString_3.java)
- **Description**: Given a string s, reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.

### Day 30: [Search a 2D Matrix II](Day30_SearchMatrix_2.java)
- **Description**: 
Write an efficient algorithm that searches for a value target in an m x n integer matrix matrix. This matrix has the following properties:

- Integers in each row are sorted in ascending from left to right.
- Integers in each column are sorted in ascending from top to bottom.

### Day 31: [Delete Node in a Linked List](Day31_DeleteNode.java)
- **Description**: 
- There is a singly-linked list head and we want to delete a node node in it.
- You are given the node to be deleted node. You will not be given access to the first node of head.
- All the values of the linked list are unique, and it is guaranteed that the given node node is not the last node in the linked list.
- Delete the given node. Note that by deleting the node, we do not mean removing it from memory. We mean:

### Day 32: [Pow(x, n)](Day32_ImplementPow.java)
- **Description**: 
- Implement pow(x, n), which calculates x raised to the power n (i.e., xn).

### Day 33: [Permutations](Day33_Permutations.java)
- **Description**: Given an array nums of distinct integers, return all the possible 
permutations. You can return the answer in any order.
 
### Day 34: [Generate Parentheses](Day34_GenerateParentheses.java)
- **Description**:
- Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.

### Day 35: [Next Permutation](Day35_NextPermutation.java)
- **Description**:
- A permutation of an array of integers is an arrangement of its members into a sequence or linear order.

### Day 36: [Reverse Integer](Day36_ReverseInteger.java)
- **Description**:
- Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.

### Day 37: [Circular Sentence](Day37_CircularSentence.java)
- **Description**:
- A sentence is a list of words that are separated by a single space with no leading or trailing spaces.

### Day 38: [Add Two Numbers](Day38_AddTwoNumbers.java)
- **Description**:
- You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.

### Day 39: [String Compression III](Day39_StringCompression.java)
- **Description**:
- Given a string word, compress it using the following algorithm:
- Begin with an empty string comp. While word is not empty, use the following operation:
- Remove a maximum length prefix of word made of a single character c repeating at most 9 times.
- Append the length of the prefix followed by c to comp.
- Return the string comp.

### Day 40: [Maximum Product Subarray](Day40_MaximumProductSubarray.java)
- **Description**:
- Given an integer array nums, find a subarray that has the largest product, and return the product.
- The test cases are generated so that the answer will fit in a 32-bit integer.

### Day 41: [Longest Substring Without Repeating Characters](Day41_LongestSubstring.java)
- **Description**:
- Given a string s, find the length of the longest substring without repeating characters.

### Day 42: [Rotate List](Day42_RotateList.java)
- **Description**:
- Given the head of a linked list, rotate the list to the right by k places.

### Day 43: [Delete the Middle Node of a Linked List](Day43_DeleteMiddleofLinkedlist.java)
- **Description**:
- You are given the head of a linked list. Delete the middle node, and return the head of the modified linked list.
- The middle node of a linked list of size n is the âŒŠn / 2âŒ‹th node from the start using 0-based indexing, where âŒŠxâŒ‹ denotes the largest integer less than or equal to x.

### Day 44: [Swapping Nodes in a Linked List](Day44_SwappingNodesLinkedList.java)
- **Description**:
- Return the head of the linked list after swapping the values of the kth node from the beginning and the kth node from the end (the list is 1-indexed).

### Day 45: [Swap Nodes in Pairs](Day45_SwapNodesPairs.java)
- **Description**:
- Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)

### Day 46: [Find the Index of the First Occurrence in a String](Day46_implementStr.java)
- **Description**:
- Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.

### Day 47: [Reverse Linked List II](Day47_ReverseLinkedList.java)
- **Description**:
- Given the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from position left to position right, and return the reversed list.

### Day 48: [Odd Even Linked List](Day48_OddEvenLinkedList.java)
- **Description**:
- Given the head of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return the reordered list.

### Day 49: [Linked List Cycle II](Day49_LinkedListCycle.java)
- **Description**:
- Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null.
- There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to (0-indexed). It is -1 if there is no cycle. Note that pos is not passed as a parameter.

### Day 50: [Insertion Sort List](Day50_InsertionSortList.java)
- **Description**:
- Given the head of a singly linked list, sort the list using insertion sort, and return the sorted list's head.
- The steps of the insertion sort algorithm:

### Day 51: [Plus One](Day51_PlusOne.java)
- **Description**:
- You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.

### Day 52: [Remove Duplicates from Sorted List](Day52_RemoveDuplicates.java)
- **Description**:
- Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well.

### Day 53: [Rotate Array](Day53_RotateArray.java)
- **Description**:
- Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.

### Day 54: [Reverse Nodes in k-Group](Day54_ReverseNodesKGroup.java)
- **Description**:
- Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.
- k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.

### Day 55: [Clear Digits](Day55_ClearDigits.java)
- **Description**:
- You are given a string s.

- Your task is to remove all digits by doing this operation repeatedly:

- Delete the first digit and the closest non-digit character to its left.
- Return the resulting string after removing all digits.

### Day 55: [Remove Duplicates from Sorted List II](Day55_RemoveDuplicatesSortedList.java)
- **Description**:
- Given the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well.

### Day 56: [Find Minimum in Rotated Sorted Array II](Day56_RemoveDuplicatesSortedList.java)
- **Description**:
- Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,4,4,5,6,7] might become
- Given the sorted rotated array nums that may contain duplicates, return the minimum element of this array.

- You must decrease the overall operation steps as much as possible.

### Day 57: [ Find a Peak Element II](Day57_FindPeakElement.java)
- **Description**:
- A peak element in a 2D grid is an element that is strictly greater than all of its adjacent neighbors to the left, right, top, and bottom.
- Given a 0-indexed m x n matrix mat where no two adjacent cells are equal, find any peak element mat[i][j] and return the length 2 array [i,j].

- You may assume that the entire matrix is surrounded by an outer perimeter with the value -1 in each cell.

- You must write an algorithm that runs in O(m log(n)) or O(n log(m)) time.


### Day 58: [ Kth Smallest Element in a Sorted Matrix](Day58_Kth Smallest Element.java)
- **Description**:
- Given an n x n matrix where each of the rows and columns is sorted in ascending order, return the kth smallest element in the matrix.

- Note that it is the kth smallest element in the sorted order, not the kth distinct element.

- You must find a solution with a memory complexity better than O(n2).

### Day 59: [Diagonal Traverse](Day59_DiagonalTraverse.java)
- **Description**:
- Given an m x n matrix mat, return an array of all the elements of the array in a diagonal order.

### Day 60: [Binary Tree Level Order Traversal](Day60_LevelOrderTraversal.java)
- **Description**:
- Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).

### Day 61: [Find First and Last Position of Element in Sorted Array](Day61_FindFirstLastPosition.java)
- **Description**:
- Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.

- If target is not found in the array, return [-1, -1].

- You must write an algorithm with O(log n) runtime complexity.

### Day 62: [Find First and Last Position of Element in Sorted Array](Day62_FindFirstLastPosition.java)
- **Description**:

### Day 63: [Find First and Last Position of Element in Sorted Array](Day63_FindFirstLastPosition.java)
- **Description**:

### Day 64: [ Next Greater Node In Linked List](Day64_NextGreaterNode.java)
- **Description**:
- You are given the head of a linked list with n nodes.

- For each node in the list, find the value of the next greater node. That is, for each node, find the value of the first node that is next to it and has a strictly larger value than it.

- Return an integer array answer where answer[i] is the value of the next greater node of the ith node (1-indexed). If the ith node does not have a next greater node, set answer[i] = 0.

### Day 65: [ Binary Tree Zigzag Level Order Traversal](Day65_BinaryTreeZigzag.java)
- **Description**:

### Day 66: [ Check If a Word Occurs As a Prefix of Any Word in a Sentence](Day66_BinaryTreeZigzag.java)
- **Description**:

- Given a sentence that consists of some words separated by a single space, and a searchWord, check if searchWord is a prefix of any word in sentence.

- Return the index of the word in sentence (1-indexed) where searchWord is a prefix of this word. If searchWord is a prefix of more than one word, return the index of the first word (minimum index). If there is no such word return -1.

- A prefix of a string s is any leading contiguous substring of s

### Day 67: [ Longest Substring with At Least K Repeating Characters](Day67_LongestSubstring.java)
- **Description**:

- Given a string s and an integer k, return the length of the longest substring of s such that the frequency of each character in this substring is greater than or equal to k.
- if no such substring exists, return 0.

### Day 68: [  Kth Smallest Element in a BST](Day68_KthSmallestElement.java)
- **Description**:
- Given the root of a binary search tree, and an integer k, return the kth smallest value (1-indexed) of all the values of the nodes in the tree.

### Day 68: [  Kth Smallest Element in a BST](Day68_KthSmallestElement.java)
- **Description**:

## ðŸ”§ How to Contribute

Feel free to contribute by submitting pull requests or opening issues for improvements or additional challenges. Collaboration is encouraged! 


